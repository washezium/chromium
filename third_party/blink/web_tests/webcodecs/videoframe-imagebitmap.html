<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script>
  'use strict';
  // Reference values generated by:
  // https://fiddle.skia.org/c/f100d4d5f085a9e09896aabcbc463868

  const kSRGBPixel = [50, 100, 150, 255];
  const kP3Pixel = [62, 99, 146, 255];
  const kRec2020Pixel = [87, 106, 151, 255];

  const kCanvasOptionsP3Uint8 = {colorSpace: 'p3', pixelFormat:'uint8'};
  const kCanvasOptionsRec2020Uint8 =
      {colorSpace: 'rec2020', pixelFormat:'uint8'};

  function testCanvas(ctx, width, height, expected_pixel, assert_compares) {
    // The dup getImageData is to workaournd crbug.com/1100233
    let imageData = ctx.getImageData(0, 0, width, height);
    let colorData = ctx.getImageData(0, 0, width, height).data;
    for (let i = 0; i < 4 * width * height; i += 4) {
      assert_compares(colorData[i], expected_pixel[0]);
      assert_compares(colorData[i + 1], expected_pixel[1]);
      assert_compares(colorData[i + 2], expected_pixel[2]);
      assert_compares(colorData[i + 3], expected_pixel[3]);
    }
  }

  function testImageBitmapToAndFromVideoFrame(width, height, expectedPixel,
      canvasOptions, imageBitmapOptions) {
    let canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    let ctx = canvas.getContext('2d', canvasOptions);
    ctx.fillStyle = 'rgb(50, 100, 150)';
    ctx.fillRect(0, 0, width, height);
    testCanvas(ctx, width, height, expectedPixel, assert_equals);

    return createImageBitmap(canvas, imageBitmapOptions)
    .then((fromImageBitmap) => {
      let videoFrame = new VideoFrame({ timestamp: 0 }, fromImageBitmap);
      return videoFrame.createImageBitmap(imageBitmapOptions);
    })
    .then((toImageBitmap) => {
        let myCanvas = document.createElement('canvas');
        myCanvas.width = width;
        myCanvas.height = height;
        let myCtx = myCanvas.getContext('2d', canvasOptions);
        myCtx.drawImage(toImageBitmap, 0, 0);
        let tolerance = 2;
        testCanvas(myCtx, width, height, expectedPixel, (actual, expected) => {
          assert_approx_equals(actual, expected, tolerance);
        });
    });
  }

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(320, 240, kSRGBPixel);
  }, 'ImageBitmap<->VideoFrame with canvas(320x240 srgb uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(640, 480, kSRGBPixel);
  }, 'ImageBitmap<->VideoFrame with canvas(640x480 srgb uint8).');

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(320, 240, kP3Pixel,
      kCanvasOptionsP3Uint8, {colorSpaceConversion: "none"});
  }, 'ImageBitmap<->VideoFrame with canvas(320x240 p3 uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(640, 480, kP3Pixel,
      kCanvasOptionsP3Uint8, {colorSpaceConversion: "none"});
  }, 'ImageBitmap<->VideoFrame with canvas(640x480 p3 uint8).');

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(320, 240, kRec2020Pixel,
      kCanvasOptionsRec2020Uint8, {colorSpaceConversion: "none"});
  }, 'ImageBitmap<->VideoFrame with canvas(320x240 rec2020 uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(640, 480, kRec2020Pixel,
      kCanvasOptionsRec2020Uint8, {colorSpaceConversion: "none"});
  }, 'ImageBitmap<->VideoFrame with canvas(640x480 rec2020 uint8).');

</script>
