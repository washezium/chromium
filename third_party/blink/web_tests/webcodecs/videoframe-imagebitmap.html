<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script>
  'use strict';
  // Reference values generated by:
  // https://fiddle.skia.org/c/f100d4d5f085a9e09896aabcbc463868

  const kSRGBPixel = [50, 100, 150, 255];
  const kP3Pixel = [62, 99, 146, 255];
  const kRec2020Pixel = [87, 106, 151, 255];

  const kCanvasOptionsP3Uint8 = { colorSpace: 'p3', pixelFormat: 'uint8' };
  const kCanvasOptionsRec2020Uint8 =
    { colorSpace: 'rec2020', pixelFormat: 'uint8' };

  function testCanvas(ctx, width, height, expected_pixel, assert_compares) {
    // The dup getImageData is to workaournd crbug.com/1100233
    let imageData = ctx.getImageData(0, 0, width, height);
    let colorData = ctx.getImageData(0, 0, width, height).data;
    const kMaxPixelToCheck = 128 * 96;
    let step = width * height / kMaxPixelToCheck;
    step = Math.round(step);
    step = (step < 1) ? 1 : step;
    for (let i = 0; i < 4 * width * height; i += (4 * step)) {
      assert_compares(colorData[i], expected_pixel[0]);
      assert_compares(colorData[i + 1], expected_pixel[1]);
      assert_compares(colorData[i + 2], expected_pixel[2]);
      assert_compares(colorData[i + 3], expected_pixel[3]);
    }
  }

  function testImageBitmapToAndFromVideoFrame(width, height, expectedPixel,
    canvasOptions, imageBitmapOptions) {
    let canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    let ctx = canvas.getContext('2d', canvasOptions);
    ctx.fillStyle = 'rgb(50, 100, 150)';
    ctx.fillRect(0, 0, width, height);
    testCanvas(ctx, width, height, expectedPixel, assert_equals);

    return createImageBitmap(canvas, imageBitmapOptions)
      .then((fromImageBitmap) => {
        let videoFrame = new VideoFrame({ timestamp: 0 }, fromImageBitmap);
        return videoFrame.createImageBitmap(imageBitmapOptions);
      })
      .then((toImageBitmap) => {
        let myCanvas = document.createElement('canvas');
        myCanvas.width = width;
        myCanvas.height = height;
        let myCtx = myCanvas.getContext('2d', canvasOptions);
        myCtx.drawImage(toImageBitmap, 0, 0);
        let tolerance = 2;
        testCanvas(myCtx, width, height, expectedPixel, (actual, expected) => {
          assert_approx_equals(actual, expected, tolerance);
        });
      });
  }

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(48, 36, kSRGBPixel);
  }, 'ImageBitmap<->VideoFrame with canvas(48x36 srgb uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(480, 360, kSRGBPixel);
  }, 'ImageBitmap<->VideoFrame with canvas(480x360 srgb uint8).');

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(48, 36, kP3Pixel,
      kCanvasOptionsP3Uint8, { colorSpaceConversion: "none" });
  }, 'ImageBitmap<->VideoFrame with canvas(48x36 p3 uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(480, 360, kP3Pixel,
      kCanvasOptionsP3Uint8, { colorSpaceConversion: "none" });
  }, 'ImageBitmap<->VideoFrame with canvas(480x360 p3 uint8).');

  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(48, 36, kRec2020Pixel,
      kCanvasOptionsRec2020Uint8, { colorSpaceConversion: "none" });
  }, 'ImageBitmap<->VideoFrame with canvas(48x36 rec2020 uint8).');
  promise_test(() => {
    return testImageBitmapToAndFromVideoFrame(480, 360, kRec2020Pixel,
      kCanvasOptionsRec2020Uint8, { colorSpaceConversion: "none" });
  }, 'ImageBitmap<->VideoFrame with canvas(480x360 rec2020 uint8).');

</script>
