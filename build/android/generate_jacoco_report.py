#!/usr/bin/env python

# Copyright 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Aggregates Jacoco coverage files to produce output."""

from __future__ import print_function

import argparse
import fnmatch
import json
import os
import shutil
import sys
from xml.dom import minidom

import devil_chromium
from devil.utils import cmd_helper
from pylib.constants import host_paths


_BUILD_UTILS_PATH = os.path.join(host_paths.DIR_SOURCE_ROOT, 'build', 'android',
                                 'gyp')
with host_paths.SysPath(_BUILD_UTILS_PATH, 0):
  from util import build_utils

_JAVA_COVERAGE_METRICS = [
    'instruction', 'branch', 'line', 'complexity', 'method', 'class'
]
# Source paths should be passed to Jacoco in a way that the relative file paths
# reflect the class package name.
_PARTIAL_PACKAGE_NAMES = ['com/google', 'org/chromium']

# The sources_json_file is generated by jacoco_instr.py with source directories
# and input path to non-instrumented jars.
# e.g.
# 'source_dirs': [
#   "chrome/android/java/src/org/chromium/chrome/browser/toolbar/bottom",
#   "chrome/android/java/src/org/chromium/chrome/browser/ui/system",
# ...]
# 'input_path':
#   '$CHROMIUM_OUTPUT_DIR/\
#    obj/chrome/android/features/tab_ui/java__process_prebuilt-filtered.jar'

_SOURCES_JSON_FILES_SUFFIX = '__jacoco_sources.json'
# These should match the jar class files generated in internal_rules.gni
_DEVICE_CLASS_EXCLUDE_SUFFIX = 'host_filter.jar'
_HOST_CLASS_EXCLUDE_SUFFIX = 'device_filter.jar'


def _AddMissingNodes(device_dict, host_dict, root_node, attribute):
  # Adds any node in host that are not in device.
  for key in host_dict:
    node_attribute = host_dict[key].getAttribute(attribute)
    if node_attribute not in device_dict:
      added_node = root_node.appendChild(host_dict[key])
      device_dict[node_attribute] = added_node


def _CreateAttributeToObjectDict(element_list, attrib):
  return {e.getAttribute(attrib): e for e in element_list}


def _CreateClassfileArgs(class_files, exclude_suffix=None):
  """Returns a list of files that don't have a given suffix.

  Args:
    class_files: A list of class files.
    exclude_suffix: Suffix to look for to exclude.

  Returns:
    A list of files that don't use the suffix.
  """
  result_class_files = []
  for f in class_files:
    if exclude_suffix:
      if not f.endswith(exclude_suffix):
        result_class_files += ['--classfiles', f]
    else:
      result_class_files += ['--classfiles', f]

  return result_class_files


def _CombineXmlFiles(combined_file_path, device_file_path, host_file_path):
  """Combines two xml jacoco report files into one.

  Expected input is two jacoco coverage report xml files.
  The report is composed of a tree of nodes, the root node is the "report" node
  which contains counters and packages.
  -The package nodes contain class nodes, sourcefile nodes, and counters.
  -The sourcefile nodes contain the file name, line nodes, and counters
  -The class nodes contain the class's name, method nodes, and counters
  -The method nodes contain the method's name and counters.
  -The line nodes contain 4 attributes,
    nr=line number corresponding to the physical line in the sourcefile.
    mi=missed instructions for the line
    ci=covered instructiosn for the line
    mb=missed branch for the line
    cb=covered branch for the line

  The counters contain an instruction type as found in _JAVA_COVERAGE_METRICS
  and the total number of "covered" or "missed" items on that metric in that
  node. So a class node's counters contain the sum of counters in the methods.
  The package node's counters contain the sum total of the counters in the
  sourcefile nodes. The sourcefile nodes contain the sum total of the counters
  in the line node.

  The code walks down to each method in the device report and finds
  the matching method in the host_report. It then chooses to use the coverage
  data from whichever node is higher. This is not perfect as device can have
  10 covered and 10 missed, and host can have 15 covered and 5 missed, so
  maybe it should be 20 covered and 0 missed if the coverage overlaps properly.
  If a method/class/package is in the host report and not in the device report,
  it adds it into hte device_report.

  The code then walks down the sourcefiles and adds to device_report any lines
  that are in host_report and not already present. It then compares every line
  in device_report to host_report and chooses to use the line that has higher
  ci. It then calculates a new sum for the counters in sourcefile and packages
  and reports (not classes and methods).

  Args:
    combined_file_path: Where to write the combined report file to.
    device_file_path: The location of the device coverage report.
    host_file_path:The location of the device coverage report.

  Returns:
    Results are written to combined_file_path
  """
  device_tree = minidom.parse(device_file_path)
  host_tree = minidom.parse(host_file_path)
  device_report_node = device_tree.getElementsByTagName('report')[0]
  device_packages = device_tree.getElementsByTagName('package')
  host_packages = host_tree.getElementsByTagName('package')
  device_name_to_package_dict = _CreateAttributeToObjectDict(
      device_packages, 'name')
  host_name_to_package_dict = _CreateAttributeToObjectDict(
      host_packages, 'name')

  _UpdateAllNodesToHigherCoverage(device_name_to_package_dict,
                                  host_name_to_package_dict)
  _AddMissingNodes(device_name_to_package_dict, host_name_to_package_dict,
                   device_report_node, 'name')

  # Only updates one layer of counters, ie doesn't do grandchildren.
  _UpdateChildrenCounters(device_report_node, 'package')

  with open(combined_file_path, 'w') as xmlfile:
    device_tree.writexml(xmlfile)


def _CreateCounterMap(counter_list):
  # Creates a map of counter types to the counter node.
  counter_map = {
      counter.getAttribute('type').lower(): counter
      for counter in counter_list
  }

  return counter_map


def _GetCoveredAndMissedFromCounter(counter):
  return (counter.getAttribute('covered'), counter.getAttribute('missed'))


def _GetDictForEachElement(device_node, host_node, children_tag, attribute_tag):
  # Returns dictionaries mapping the attribute tag to the node's children.
  device_children = device_node.getElementsByTagName(children_tag)
  host_children = host_node.getElementsByTagName(children_tag)
  device_mapping_dict = _CreateAttributeToObjectDict(device_children,
                                                     attribute_tag)
  host_mapping_dict = _CreateAttributeToObjectDict(host_children, attribute_tag)
  return (device_mapping_dict, host_mapping_dict)


def _CreateTotalDicts():
  total_dicts = {}
  for metric in _JAVA_COVERAGE_METRICS:
    new_dict = {'covered': 0, 'missed': 0}
    total_dicts[metric] = new_dict

  return total_dicts


def _GenerateReportOutputArgs(args,
                              class_files,
                              class_jar_exclude,
                              report_name=None,
                              report_file=None):
  cmd = _CreateClassfileArgs(class_files, class_jar_exclude)
  if args.format == 'html':
    report_dir = os.path.join(args.output_dir, report_name)
    if not os.path.exists(report_dir):
      os.makedirs(report_dir)
    cmd += ['--html', report_dir]
  elif args.format == 'xml':
    cmd += ['--xml', report_file]
  elif args.format == 'csv':
    cmd += ['--csv', report_file]

  return cmd


def _GetCountersList(root_node):
  return [node for node in root_node.childNodes if node.tagName == 'counter']


def _GetFilesWithSuffix(root_dir, suffix):
  """Gets all files with a given suffix.

  Args:
    root_dir: Directory in which to search for files.
    suffix: Suffix to look for.

  Returns:
    A list of absolute paths to files that match.
  """
  files = []
  for root, _, filenames in os.walk(root_dir):
    basenames = fnmatch.filter(filenames, '*' + suffix)
    files.extend([os.path.join(root, basename) for basename in basenames])

  return files


def _SetHigherCounter(device_counter, host_counter):
  # Ideally would use min/max on covered and missed, but want to make sure
  # to use the variables from the same counter.
  if int(device_counter.getAttribute('covered')) >= int(
      host_counter.getAttribute('covered')):
    chosen_counter = device_counter
  else:
    chosen_counter = host_counter

  covered, missed = _GetCoveredAndMissedFromCounter(chosen_counter)
  device_counter.setAttribute('covered', covered)
  device_counter.setAttribute('missed', missed)


def _SetHigherMethodCoverage(device_method_dict, host_method_dict):
  for method_key in device_method_dict:
    device_method = device_method_dict[method_key]
    if method_key not in host_method_dict:
      continue

    device_counter_map = _CreateCounterMap(
        device_method.getElementsByTagName('counter'))
    host_counter_map = _CreateCounterMap(
        host_method_dict[method_key].getElementsByTagName('counter'))
    for metric in device_counter_map:
      if metric in host_counter_map:
        _SetHigherCounter(device_counter_map[metric], host_counter_map[metric])


def _UpdateAllNodesToHigherCoverage(device_package_dict, host_package_dict):
  # Go to every package, then every class in the package, then every method
  # in the class and choose the coverage that is higher.
  for key in device_package_dict:
    device_package = device_package_dict[key]
    if key not in host_package_dict:
      continue
    host_package = host_package_dict[key]
    device_class_dict, host_class_dict = _GetDictForEachElement(
        device_package, host_package, 'class', 'name')
    _AddMissingNodes(device_class_dict, host_class_dict, device_package, 'name')
    for class_key in device_class_dict:
      device_class = device_class_dict[class_key]
      if class_key not in host_class_dict:
        continue
      host_class = host_class_dict[class_key]
      device_method_dict, host_method_dict = _GetDictForEachElement(
          device_class, host_class, 'method', 'line')
      _AddMissingNodes(device_method_dict, host_method_dict, device_class,
                       'line')
      # Rewrite the values in method coverage based on which is higher.
      # Then update the counter at the class level.
      _SetHigherMethodCoverage(device_method_dict, host_method_dict)
      _UpdateChildrenCounters(device_class, 'method')

    _UpdatePackageSourceFiles(device_package, host_package)
    _UpdateChildrenCounters(device_package, 'sourcefile')


def _UpdateChildrenCounters(root_node, tag_name):
  # Updates the children (not deeper, ie grandchildren) of the node. This is to
  # avoid double counting counters (as a class's total counter is the summation
  # of the method counters.)
  counters = _GetCountersList(root_node)
  total_dicts = _GetCounterTotalsForTagName(root_node, tag_name)
  _UpdateCountersFromTotal(counters, total_dicts)


def _UpdateCountersFromTotal(counter_nodes, total_dicts):
  for counter in counter_nodes:
    counter_type = counter.getAttribute('type').lower()
    counter.setAttribute('covered', str(total_dicts[counter_type]['covered']))
    counter.setAttribute('missed', str(total_dicts[counter_type]['missed']))


def _GetCounterTotalsForTagName(root_node, tag_name):
  # Gets a diciontary of the totals of the counters in the children's counters.
  total_dicts = _CreateTotalDicts()
  # Cannot just use getElementByTagName as that will go more than one layer
  # deep. Want to avoid double counting the counters.
  nodes = [node for node in root_node.childNodes if node.tagName == tag_name]
  for node in nodes:
    for counter in _GetCountersList(node):
      covered_lines, missed_lines = _GetCoveredAndMissedFromCounter(counter)
      counter_type = counter.getAttribute('type').lower()
      total_dicts[counter_type]['covered'] += int(covered_lines)
      total_dicts[counter_type]['missed'] += int(missed_lines)

  return total_dicts


def _UpdateLineCodeCoverageNodes(device_dict, host_dict, device_source_node,
                                 host_source_node):
  # Gets the nodes that are in the host_tree and not in the device_tree.
  # If the node exists in both trees, choose the one that higher
  # covered instructions (ci).
  instruction_list = ['ci', 'cb', 'mi', 'mb']
  total_dict = {inst: 0 for inst in instruction_list}

  # Add any nodes that are in host, that aren't in dict. This adds the entry
  # to device_dict.
  _AddMissingNodes(device_dict, host_dict, device_source_node, 'nr')

  # Check all the lines that are the same. Set the device_node to have the
  # fields that are higher.
  for key in device_dict:
    device_line = device_dict[key]
    if key not in host_dict:
      continue

    host_line = host_dict[key]
    host_line_ci = int(host_line.getAttribute('ci'))
    device_line_ci = int(device_line.getAttribute('ci'))
    # We'll take all the data from the host line if ci is better.
    if device_line_ci < host_line_ci:
      for inst in instruction_list:
        device_line.setAttribute(inst, host_line.getAttribute(inst))

  # Sum up all the coverage numbers.
  for key in device_dict:
    device_line = device_dict[key]
    for inst in instruction_list:
      total_dict[inst] += int(device_line.getAttribute(inst))

  _UpdateSourceFileCounters(device_source_node, host_source_node, total_dict)


def _UpdatePackageSourceFiles(device_package, host_package):
  # Adds any source files in the host_tree that are not in the device_tree.
  # One the source file that are the same, combine the source files
  # based on "nr"(line number)
  device_sources = device_package.getElementsByTagName('sourcefile')
  host_sources = host_package.getElementsByTagName('sourcefile')

  device_name_to_sources_dict = _CreateAttributeToObjectDict(
      device_sources, 'name')
  host_name_to_sources_dict = _CreateAttributeToObjectDict(host_sources, 'name')

  # Adds any source files that are in the host package that
  # are not in the device package.
  _AddMissingNodes(device_name_to_sources_dict, host_name_to_sources_dict,
                   device_package, 'name')

  for key in device_name_to_sources_dict:
    device_source_node = device_name_to_sources_dict[key]
    host_source_node = host_name_to_sources_dict[key]
    device_line_dict = _CreateAttributeToObjectDict(
        device_source_node.getElementsByTagName('line'), 'nr')
    host_line_dict = _CreateAttributeToObjectDict(
        host_source_node.getElementsByTagName('line'), 'nr')
    # Takes all the "lines" in the source file, then compares them and chooses
    # the "line" that has higher coverage.
    _UpdateLineCodeCoverageNodes(device_line_dict, host_line_dict,
                                 device_source_node, host_source_node)


def _UpdateSourceFileCounters(device_source_node, host_source_node, total_dict):
  # Update the counter nodes of the source file.
  device_counter_dict = _CreateAttributeToObjectDict(
      device_source_node.getElementsByTagName('counter'), 'type')
  host_counter_dict = _CreateAttributeToObjectDict(
      host_source_node.getElementsByTagName('counter'), 'type')
  for inst in device_counter_dict:
    device_counter = device_counter_dict[inst]
    if inst == 'INSTRUCTION':
      device_counter.setAttribute('covered', str(total_dict['ci']))
      device_counter.setAttribute('missed', str(total_dict['mi']))
    elif inst == 'BRANCH':
      device_counter.setAttribute('covered', str(total_dict['cb']))
      device_counter.setAttribute('missed', str(total_dict['mb']))
    else:
      covered_val = max(int(device_counter.getAttribute('covered')),
                        int(host_counter_dict[inst].getAttribute('covered')))
      missed_val = min(int(device_counter.getAttribute('missed')),
                       int(host_counter_dict[inst].getAttribute('missed')))
      device_counter.setAttribute('covered', str(covered_val))
      device_counter.setAttribute('missed', str(missed_val))


def _ParseArguments(parser):
  """Parses the command line arguments.

  Args:
    parser: ArgumentParser object.

  Returns:
    The parsed arguments.
  """
  parser.add_argument(
      '--format',
      required=True,
      choices=['html', 'xml', 'csv'],
      help='Output report format. Choose one from html, xml and csv.')
  parser.add_argument('--output-dir', help='html report output directory.')
  parser.add_argument('--output-file',
                      help='xml file to write device coverage results.')
  parser.add_argument(
      '--coverage-dir',
      required=True,
      help='Root of the directory in which to search for '
      'coverage data (.exec) files.')
  parser.add_argument(
      '--sources-json-dir',
      help='Root of the directory in which to search for '
      '*__jacoco_sources.json files.')
  parser.add_argument(
      '--class-files',
      nargs='+',
      help='Location of Java non-instrumented class files. '
      'Use non-instrumented jars instead of instrumented jars. '
      'e.g. use chrome_java__process_prebuilt-filtered.jar instead of'
      'chrome_java__process_prebuilt-instrumented.jar')
  parser.add_argument(
      '--sources',
      nargs='+',
      help='Location of the source files. '
      'Specified source folders must be the direct parent of the folders '
      'that define the Java packages.'
      'e.g. <src_dir>/chrome/android/java/src/')
  parser.add_argument(
      '--cleanup',
      action='store_true',
      help='If set, removes coverage files generated at '
      'runtime.')
  args = parser.parse_args()

  if args.format in ('csv', 'html'):
    if not args.output_dir:
      parser.error('--output-dir needed for report.')
  if args.format == 'xml' and not args.output_file:
    parser.error(('--output-junit-coverage-file/--output-device-coverage-file '
                  'needed for xml/csv reports.'))

  if not (args.sources_json_dir or args.class_files):
    parser.error('At least either --sources-json-dir or --class-files needed.')

  return args


def main():
  parser = argparse.ArgumentParser()
  args = _ParseArguments(parser)

  devil_chromium.Initialize()

  coverage_files = _GetFilesWithSuffix(args.coverage_dir, '.exec')
  if not coverage_files:
    parser.error('No coverage file found under %s' % args.coverage_dir)
  print('Found coverage files: %s' % str(coverage_files))

  class_files = []
  source_dirs = []
  if args.sources_json_dir:
    sources_json_files = _GetFilesWithSuffix(args.sources_json_dir,
                                             _SOURCES_JSON_FILES_SUFFIX)
    for f in sources_json_files:
      with open(f, 'r') as json_file:
        data = json.load(json_file)
        class_files.extend(data['input_path'])
        source_dirs.extend(data['source_dirs'])

  # Fix source directories as direct parent of Java packages.
  fixed_source_dirs = set()
  for path in source_dirs:
    for partial in _PARTIAL_PACKAGE_NAMES:
      if partial in path:
        fixed_dir = os.path.join(host_paths.DIR_SOURCE_ROOT,
                                 path[:path.index(partial)])
        fixed_source_dirs.add(fixed_dir)
        break

  if args.class_files:
    class_files += args.class_files
  if args.sources:
    fixed_source_dirs.update(args.sources)

  cmd = [
      'java', '-jar',
      os.path.join(host_paths.DIR_SOURCE_ROOT, 'third_party', 'jacoco', 'lib',
                   'jacococli.jar'), 'report'
  ] + coverage_files

  for source in fixed_source_dirs:
    cmd += ['--sourcefiles', source]

  with build_utils.TempDir() as temp_dir:
    temp_device_file = os.path.join(temp_dir, 'temp_device')
    temp_host_file = os.path.join(temp_dir, 'temp_host')

    device_cmd = cmd + _GenerateReportOutputArgs(
        args, class_files, _DEVICE_CLASS_EXCLUDE_SUFFIX, 'device_report',
        temp_device_file)
    host_cmd = cmd + _GenerateReportOutputArgs(
        args, class_files, _HOST_CLASS_EXCLUDE_SUFFIX, 'host_report',
        temp_host_file)

    device_exit_code = cmd_helper.RunCmd(device_cmd)
    host_exit_code = cmd_helper.RunCmd(host_cmd)
    exit_code = device_exit_code or host_exit_code

    if args.format == 'xml':
      _CombineXmlFiles(args.output_file, temp_device_file, temp_host_file)
      print('Combined device and junit reports.')
    elif args.format == 'csv':
      shutil.copyfile(temp_device_file,
                      os.path.join(args.output_dir, 'device.csv'))
      shutil.copyfile(temp_host_file, os.path.join(args.output_dir, 'host.csv'))

  if args.cleanup:
    for f in coverage_files:
      os.remove(f)

  # Command tends to exit with status 0 when it actually failed.
  if not exit_code:
    if args.format in ('html', 'csv'):
      if not os.path.isdir(args.output_dir) or not os.listdir(args.output_dir):
        print('No report generated at %s' % args.output_dir)
        exit_code = 1
    elif not os.path.isfile(args.output_file):
      print('No device coverage report generated at %s' % args.output_file)
      exit_code = 1

  return exit_code


if __name__ == '__main__':
  sys.exit(main())
