// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file provides common functionality for different configurations of test
// extensions using the chrome.certificateProvider API.

'use strict';

const assertEq = chrome.test.assertEq;
const assertTrue = chrome.test.assertTrue;
const callbackPass = chrome.test.callbackPass;

// X.509 certificate in DER encoding issued by 'root.pem' which is set to be
// trusted by the test setup.
// Read from 'l1_leaf.der', generated by create_test_certs.sh .
let l1LeafCert = null;
let validCertInfo = null;
const INVALID_CERT = new Uint8Array([1, 2, 3, 4, 5]);
const INVALID_CERT_INFO = {
  certificate: INVALID_CERT.buffer,
  supportedHashes: ['SHA256']
};

function registerAsCertificateProvider() {
  function checkResult(rejectedCerts) {
    assertEq(1, rejectedCerts.length);
    assertEq(INVALID_CERT, new Uint8Array(rejectedCerts[0]));
  }

  function reportCertificates(reportCallback) {
    reportCallback(
        [validCertInfo, INVALID_CERT_INFO], callbackPass(checkResult));
  }

  chrome.certificateProvider.onCertificatesRequested.addListener(
      callbackPass(reportCertificates));
}

// Use setCertificates to let the extension proactively provide certificates.
// This can be combined with registerAsCertificateProvider(), but can also be
// used on its own.
function setCertificates() {
  chrome.certificateProvider.setCertificates(
      [validCertInfo, INVALID_CERT_INFO], () => {
        const success = !chrome.runtime.lastError;
        domAutomationController.send(success);
      });
}

// Indicates that there are no certificates available.
function unsetCertificates() {
  chrome.certificateProvider.setCertificates([], () => {
    const success = !chrome.runtime.lastError;
    domAutomationController.send(success);
  });
}

let signDigestRequest;
let signCallback;

function registerForSignDigests() {
  chrome.certificateProvider.onSignDigestRequested.addListener(function(
      request, callback) {
    assertEq(l1LeafCert.buffer, request.certificate);
    // The sign request must refer to the only hash that was declared to be
    // supported.
    assertEq(1, validCertInfo.supportedHashes.length);
    assertEq(validCertInfo.supportedHashes[0], request.hash);
    signCallback = callback;
    signDigestRequest = request;
    chrome.test.sendMessage('SignDigestRequest received');
  });
}

function replyWithSignature(signature) {
  signCallback(signature.buffer);
}

function replyWithSignatureSecondTime() {
  const signature = new Uint8Array([1, 2, 3]);
  try {
    signCallback(signature.buffer);
  } catch (e) {
    domAutomationController.send(false);
    return false;
  }
  domAutomationController.send(true);
  return true;
}

// initialize is called from the cpp test.
// |cert| is the certificate data in an Uint8Array.
function initialize(cert) {
  l1LeafCert = cert;
  validCertInfo = {certificate: l1LeafCert.buffer, supportedHashes: ['SHA1']};
}
