// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_BASE_MODELS_DIALOG_MODEL_FIELD_H_
#define UI_BASE_MODELS_DIALOG_MODEL_FIELD_H_

#include "base/callback.h"
#include "base/containers/flat_set.h"
#include "base/strings/string16.h"
#include "base/util/type_safety/pass_key.h"
#include "ui/base/accelerators/accelerator.h"
#include "ui/base/models/combobox_model.h"

namespace ui {

class DialogModel;
class DialogModelHost;
class Event;

// These "field" classes represent entries in a DialogModel. They are owned
// by the model and either created through the model or DialogModel::Builder.
// These entries can be referred to by setting the field's unique id in
// construction parameters (::Params::SetUniqueId()). They can then later be
// acquired through DialogModel::GetFieldByUniqueId() methods.
// These fields own the data corresponding to their field. For instance, the
// text of a textfield in a model is read using DialogModelTextfield::text() and
// stays in sync with the visible dialog (through DialogModelHosts).
class COMPONENT_EXPORT(UI_BASE) DialogModelField {
 public:
  enum Type { kButton, kTextfield, kCombobox };

  DialogModelField(const DialogModelField&) = delete;
  DialogModelField& operator=(const DialogModelField&) = delete;
  virtual ~DialogModelField();

  // Accessors with util::PassKey<DialogModelHost> are only intended to be read
  // by the DialogModelHost implementation.
  const base::flat_set<Accelerator>& accelerators(
      util::PassKey<DialogModelHost>) const {
    return accelerators_;
  }
  // Reserved ID generated by the model. This ID is generated for every field
  // and used to map from DialogModelHost fields (like views::Textfield) to
  // DialogModelFields (like DialogModelTextfield).
  // WARNING: This should not be confused with the ID set by subclasses'
  // Params::SetUniqueId() methods.
  // TODO(pbos): See if this int-to-field mapping can be replaced with using
  // DialogModelField pointers in DialogModelHost. This is currently only used
  // because views has a convenient views::View::SetID() function.
  int model_field_id(util::PassKey<DialogModelHost>) const {
    return model_field_id_;
  }
  Type type(util::PassKey<DialogModelHost>) const { return type_; }

 protected:
  // Struct that holds a reserved ID for the field in the model. This is
  // protected to be able to be passed from DialogModelField children to the
  // parent constructor. Its members are private because only DialogModel,
  // DialogModelField and DialogModelHost should be able to read them.
  // TODO(pbos): Reconsider whether this |model_field_id| can be avoided. This
  // would take rewiring DialogModelHost to own a mapping between
  // "DialogModelField*" and host classes (such as View) and not rely on things
  // like View::SetID(model_field_id) to maintain that mapping. It would also
  // require special handling of special buttons like DIALOG_BUTTON_OK.
  struct Reservation {
   private:
    friend class DialogModel;
    friend class DialogModelField;
    // This is only to be constructed by DialogModel who makes the actual
    // ID assignment.
    Reservation(DialogModel* model, int model_field_id);

    DialogModel* const model;
    const int model_field_id;
  };

  DialogModelField(const Reservation& reservation,
                   Type type,
                   int unique_id,
                   base::flat_set<Accelerator> accelerators);

  int model_field_id() const { return model_field_id_; }

 private:
  friend class DialogModel;

  DialogModel* const model_;
  const int model_field_id_;
  const Type type_;

  const int unique_id_;

  const base::flat_set<Accelerator> accelerators_;
};

// Field class representing a dialog button.
class COMPONENT_EXPORT(UI_BASE) DialogModelButton : public DialogModelField {
 public:
  class COMPONENT_EXPORT(UI_BASE) Params {
   public:
    Params();
    Params(const Params&) = delete;
    Params& operator=(const Params&) = delete;
    ~Params();

    Params& SetUniqueId(int unique_id);

    // The button callback gets called when the button is activated. Whether
    // that happens on key-press, release, etc. is implementation (and platform)
    // dependent.
    Params& SetCallback(base::RepeatingCallback<void(const Event&)> callback);

    Params& AddAccelerator(Accelerator accelerator);
    Params& SetAccessibleName(base::string16 accessible_name);

    bool has_callback() const { return !!callback_; }

   private:
    friend class DialogModelButton;

    int unique_id_ = -1;
    base::RepeatingCallback<void(const Event&)> callback_;
    base::flat_set<Accelerator> accelerators_;
  };

  // Note that this is constructed through a DialogModel (Reservation can't
  // be created without one).
  DialogModelButton(const Reservation& reservation,
                    base::string16 label,
                    const Params& params);
  DialogModelButton(const DialogModelButton&) = delete;
  DialogModelButton& operator=(const DialogModelButton&) = delete;
  ~DialogModelButton() override;

  const base::string16& label() const { return label_; }

 private:
  friend class DialogModel;

  const base::string16 label_;
  base::RepeatingCallback<void(const Event&)> callback_;
};

// Field class representing a combobox and corresponding label to describe the
// combobox:
//
//     <label>   [combobox]
// Ex: Folder    [My Bookmarks]
class COMPONENT_EXPORT(UI_BASE) DialogModelCombobox : public DialogModelField {
 public:
  class COMPONENT_EXPORT(UI_BASE) Params {
   public:
    Params();
    Params(const Params&) = delete;
    Params& operator=(const Params&) = delete;
    ~Params();

    Params& SetUniqueId(int unique_id);

    Params& AddAccelerator(Accelerator accelerator);
    Params& SetAccessibleName(base::string16 accessible_name);

    // The combobox callback is invoked when an item has been selected. This
    // nominally happens when selecting an item in the combobox menu. The
    // selection notably does not change by hovering different items in the
    // combobox menu or navigating it with up/down keys as long as the menu is
    // open.
    Params& SetCallback(base::RepeatingClosure callback);

   private:
    friend class DialogModelCombobox;

    const base::string16 label_;
    int unique_id_ = -1;
    base::string16 accessible_name_;
    base::RepeatingClosure callback_;
    base::flat_set<Accelerator> accelerators_;
  };

  // Note that this is constructed through a DialogModel (Reservation can't
  // be created without one).
  DialogModelCombobox(const Reservation& reservation,
                      base::string16 label,
                      std::unique_ptr<ui::ComboboxModel> combobox_model,
                      const Params& params);
  DialogModelCombobox(const DialogModelCombobox&) = delete;
  DialogModelCombobox& operator=(const DialogModelCombobox&) = delete;
  ~DialogModelCombobox() override;

  const base::string16& label() const { return label_; }
  const base::string16& accessible_name() const { return accessible_name_; }
  int selected_index() const { return selected_index_; }
  ui::ComboboxModel* combobox_model() { return combobox_model_.get(); }

 private:
  friend class DialogModel;

  const base::string16 label_;
  const base::string16 accessible_name_;
  int selected_index_;
  std::unique_ptr<ui::ComboboxModel> combobox_model_;
  base::RepeatingClosure callback_;
};

// Field class representing a textfield and corresponding label to describe the
// textfield:
//
//     <label>   [textfield]
// Ex: Name      [My email]
class COMPONENT_EXPORT(UI_BASE) DialogModelTextfield : public DialogModelField {
 public:
  class COMPONENT_EXPORT(UI_BASE) Params {
   public:
    Params();
    Params(const Params&) = delete;
    Params& operator=(const Params&) = delete;
    ~Params();

    Params& SetUniqueId(int unique_id);

    Params& AddAccelerator(Accelerator accelerator);
    Params& SetAccessibleName(base::string16 accessible_name);

   private:
    friend class DialogModelTextfield;

    int unique_id_ = -1;
    base::string16 accessible_name_;
    base::flat_set<Accelerator> accelerators_;
  };

  // Note that this is constructed through a DialogModel (Reservation can't
  // be created without one).
  DialogModelTextfield(const DialogModelField::Reservation& reservation,
                       base::string16 label,
                       base::string16 text,
                       const Params& params);
  DialogModelTextfield(const DialogModelTextfield&) = delete;
  DialogModelTextfield& operator=(const DialogModelTextfield&) = delete;
  ~DialogModelTextfield() override;

  const base::string16& label() const { return label_; }
  const base::string16& accessible_name() const { return accessible_name_; }
  const base::string16& text() const { return text_; }

 private:
  friend class DialogModel;

  const base::string16 label_;
  const base::string16 accessible_name_;
  base::string16 text_;
};

}  // namespace ui

#endif  // UI_BASE_MODELS_DIALOG_MODEL_FIELD_H_